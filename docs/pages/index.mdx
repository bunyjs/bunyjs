import { Steps, Cards } from "nextra/components";

# Introduction

Welcome to BunyJS – an event-driven IoC (Inversion of Control) library that simplifies building applications, bots, automation tools, and integrations. Designed with TypeScript-first principles, BunyJS combines powerful decorators, a robust container for dependency management, and an event-driven lifecycle to provide seamless module orchestration and flexibility.

## What is BunyJS?

BunyJS is a TypeScript-first library that accelerates application development by offering:

- **Asynchronous programming model**: Seamlessly integrates with asynchronous code, making it easier to manage complex workflows.
- **Event-driven architecture**: Built around lifecycle events to help orchestrate your application's behavior effortlessly.
- **Inversion of Control (IoC)**: Centralized container for easy registration and resolution of dependencies, promoting clean, modular designs.
- **Extensive ecosystem**: A growing collection of built-in decorators, tools, and extensions that simplify integration with the IoC container while allowing customization for advanced use cases."

### Event-Driven Lifecycle

BunyJS operates on a simple yet powerful event-driven lifecycle:


<Steps>
### Bootstrap
Initializes the application and registers modules with the IoC container.
### Init
Prepares the application for execution, resolving dependencies and performing any necessary initialization tasks.
### Start
Launches the application, running its main logic and handling operations or events.
### Shutdown
Gracefully stops the application, cleaning up resources and releasing dependencies.
</Steps>

## Why use BunyJS?

BunyJS is designed to simplify the development of modular, event-driven applications by leveraging the power of IoC.
Its flexible architecture makes it ideal for scenarios where dependency management, lifecycle control, and extensibility are critical.
Here’s what makes BunyJS stand out:

- **Event-Driven Design**: Simplifies application flow with a clear lifecycle (`Bootstrap`, `Init`, `Start`, `Shutdown`), making it easy to manage initialization and graceful shutdown.
- **Inversion of Control (IoC)**: Promotes modular design by decoupling components and centralizing dependency resolution, resulting in clean, maintainable codebases.
- **TypeScript-First Approach**: Ensures type safety, enabling developers to catch errors early and enjoy a seamless development experience.
- **Extensible and Adaptable**: Easily integrates with tools and libraries like discord.js, REST APIs, and databases, making it versatile for various use cases.

## Use Cases

BunyJS is an excellent choice for building:

- **Bots**: Develop scalable automation tools, chatbots, and other bot-driven solutions effortlessly.
- **Integrations**: Seamlessly connect to third-party services, APIs, and data sources.
- **Task-Oriented Systems**: Create workflows for automation, data processing pipelines, or event-driven architectures.

BunyJS's focus on simplicity and modularity makes it a powerful tool for developers looking to streamline application development without compromising control.
